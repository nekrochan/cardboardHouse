## 1. Прием функцией функции как аргумента
Сначала в paint() вызывается decorate(), которая возвращает лямбду, а затем вызывается эта лямбда (вторые скобки), в данном случае лямбда это вывод в консоль:

``` kotlin
paint { decorate()() }
```

Сигнатура функции:
``` kotlin
fun paint(function: () -> Unit) {
    println("3. Наносим грунт и красим модель основными цветами")
    function()
}
```

## 2. Возвращение функции из функции
...: (получает ничего) -> Unit возвращает некую лямбду {return действие}:

``` kotlin
fun decorate(): () -> Unit {
    return { println("4. Добавляем текстуры и тени") }
}
```
## 3. Функция высшего порядка
Прием функции для реализации сложного поведения, в основном вроде фильтры

https://kotlinlang.org/docs/lambdas.html

foreach вроде тоже подходит:

``` kotlin
surroundings.forEach {
    println("5. Добавляем окружение дома: $it")
}
```

## 4. Композиция
В kotlin реализуется либо через compose, либо через andThen. 
При compose сначала выполняется вторая функция, потом к ее результату применяется первая. 
В случае с andThen сначала выполняется первая функция, потом к ее результату применяется вторая. 
Скобки в передаваемых аргументах "расставляются" (мысленно) соответствующим образом.

В данном коде реализовано для подсчета количества окон в доме:

``` kotlin
// распаковка массива в переменные
val (levels, rooms, doors) = arr
fun countHoles(levels: Int, rooms: Int): Int { return levels * rooms }  // функция для вычисления количества прорезей
fun excludeDoors(holes: Int, doors: Int): Int { return holes - doors }  // окна - все прорези кроме дверей
fun compose(  // функция compose для объединения двух функций (описываем сигнатуру)
    f: (Int, Int) -> Int,
    g: (Int, Int) -> Int
): (Int, Int, Int) -> Int = { levels, rooms, doors ->
    val holes = g(levels, rooms)
    f(holes, doors)
}
val windows = compose(::excludeDoors, ::countHoles)(levels, rooms, doors)
```

Логика такая: на каждом этаже одинаковое количество отверстий (и окон, и дверей). 
Будем считать, что число отверстий равно числу помещений. 
На первом этаже вместо N окон - N дверей. Поэтому:

*[число окон] = ([число этажей] * [число комнат]) - [число дверей]*

Последовательность операций в данном выражении критична.

Если в доме 3 этажа по 6 помещений на каждом и 1 дверь на весь дом, то:

*[число окон] = (3 * 6) - 1 = 17*

## 5. Каррирование
Каррирование - преобразование функции от многих аргументов
в последовательность функций одного аргумента. 
Позволяет делать частичное применение функций - в таком случае выполнятся верхние слои.

Пример в данном коде - сама функция build, преобразование функции от многих аргументов в функцию аргумента mainPart.
